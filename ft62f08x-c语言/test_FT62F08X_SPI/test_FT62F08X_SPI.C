//********************************************************* 
/* 文件名: TEST_62F08x_SPI.c
* 功能：   FT62F08x-SPI功能演示
* IC:      FT62F088 LQFP32
* 内部：   16M/2T
* empno:   500                                
* 说明：   此演示程序为60F12x_SPI的演示程序.
*		   该程序写0x55,0x88到(FT25C64A)0x13,0x14地址,然后读取0x13,0x14的地址值  
*
*   参考原理图 TEST_62F08x_sch.pdf
*/
//********************************************************
#include "SYSCFG.h"
//***********************宏定义***************************
#define	unchar	unsigned char 
#define	unint	unsigned int

#define	CS	NSSM0
volatile unchar	SPIReadData = 0;volatile unchar	SPIReadData1 = 0;/*-------------------------------------------------
 * 函数名：interrupt ISR
 * 功能：  中断处理，包括定时器0中断和外部中断
 * 输入：  无
 * 输出：  无
 --------------------------------------------------*/
void interrupt ISR(void)            	
{ 
	
}
/*-------------------------------------------------
 * 函数名：POWER_INITIAL
 * 功能：  上电系统初始化
 * 输入：  无
 * 输出：  无
 --------------------------------------------------*/	
void POWER_INITIAL (void) 
{ 
	OSCCON = 0B01110001;	//IRCF=111=16MHz 1:1
	INTCON = 0;  			//暂禁止所有中断
    
	PORTA = 0B00000000;		
	TRISA = 0B00000010;		//PA输入输出 0-输出 1-输入 PA1-输入
	PORTB = 0B00000000;		
	TRISB = 0B00000000;		//PB输入输出 0-输出 1-输入							
	PORTC = 0B00000000; 	
	TRISC = 0B00000000;		//PC输入输出 0-输出 1-输入  	
    PORTD = 0B00000000;		
	TRISD = 0B00000000;		//PD输入输出 0-输出 1-输入
	
	WPUA = 0B00000010;     	//PA端口上拉控制 1-开上拉 0-关上拉
	WPUB = 0B00000000;     	//PB端口上拉控制 1-开上拉 0-关上拉
	WPUC = 0B00000000;     	//PC端口上拉控制 1-开上拉 0-关上拉
	WPUD = 0B00000000;     	//PD端口上拉控制 1-开上拉 0-关上拉
    
    WPDA = 0B00000000;     	//PA端口下拉控制 1-开下拉 0-关下拉
	WPDB = 0B00000000;     	//PB端口下拉控制 1-开下拉 0-关下拉
	WPDC = 0B00000000;     	//PC端口下拉控制 1-开下拉 0-关下拉
	WPDD = 0B00000000;     	//PD端口下拉控制 1-开下拉 0-关下拉
    
    PSRC0 = 0B11111111;  	//PORTA,PORTB源电流设置最大
    PSRC1 = 0B11111111;    	//PORTC,PORTD源电流设置最大    
    
    PSINK0 = 0B11111111;  	//PORTA灌电流设置最大 0:最小，1:最大
    PSINK1 = 0B11111111; 	//PORTB灌电流设置最大 0:最小，1:最大
    PSINK2 = 0B11111111;	//PORTC灌电流设置最大 0:最小，1:最大
    PSINK3 = 0B11111111;	//PORTD灌电流设置最大 0:最小，1:最大
	
    ANSELA = 0B00000000;    //全为数字管脚
}
/*-------------------------------------------------
 * 函数名：SPI_RW
 * 功能：  主机输出以及输入一个字节
 * 输入：  data
 * 输出：  根据接收的data输出给从机一个字节
 --------------------------------------------------*/		  
unchar SPI_RW(unchar data)
{
	unchar spiData; 
   
	while(BUSY);  			//等待SPI模块空闲
    SPIDATA = data;
    while(RXBMT);    
    spiData = SPIDATA;
	return spiData;
 }
/*-------------------------------------------------
 * 函数名：WriteEnable
 * 功能：  写允许（将WEN置位） 
 --------------------------------------------------*/
void WriteEnable(void)
{
    CS=0;
    SPI_RW(0x06);  
    CS=1;
}
/*-------------------------------------------------
 * 函数名：WriteDisable
 * 功能：  写禁止（将WEN复位） 
 --------------------------------------------------*/
 void WriteDisable (void)
{
    CS=0;
    SPI_RW(0x04);  
    CS=1;
}
/*-------------------------------------------------
 * 功能：  读取25C64芯片的状态。
 * 返回值：状态寄存器数据字节
 * 注：25C64内部状态寄存器第0位=0表示空闲，0位=1表示忙。
 --------------------------------------------------*/
unchar SPI_ReadStatus(void)
{
    unchar status=0;
    CS=0;
    SPI_RW(0x05);                 //0x05读取状态的命令字
    status = SPI_RW(0x00);        
    CS=1;                         //关闭片选
    return status;
}  
/*-------------------------------------------------
 * 程序名：SPI_WriteStatus
 * 功能：  写25C64芯片的状态寄存器。
 *         只有BP1、BP0 (bit7、3、2)可以写、
 * 注：25c64内部状态寄存器第0位=0表示空闲，0位=1表示忙。
 --------------------------------------------------*/
void SPI_WriteStatus(unchar Status)
{
    CS=0;
    SPI_RW(0X01);  		          //0x01读取状态的命令字
    SPI_RW(Status);               //写入一个字节
    CS=1;                         //关闭片选
}
/*-------------------------------------------------
 * 程序名：SPI_Read
 * 输入:   16位的地址
 * 返回:   读取的数据
 * 说明：  从25c64指定的地址读取一个字节
 --------------------------------------------------*/
unchar SPI_Read(unint addr)
{
	unchar spidata;
    while(SPI_ReadStatus()&0x01);       //判断是否忙
    CS=0;                               //使能器件   
    SPI_RW(0x03);                       //发送读取命令   
    SPI_RW((unsigned char)((addr)>>8));
    SPI_RW((unsigned char)addr);
  	spidata = SPI_RW(0x00);             //读出数据  
    CS=1;  
  	return spidata;            
}
/*-------------------------------------------------
 * 程序名：SPI_Write
 * 输入:   地址，字节数据
 * 说明：  将一个字节写入指定的地址
 --------------------------------------------------*/
void SPI_Write(unint addr,unchar dat)
{
    while(SPI_ReadStatus()&0x01);       //判断是否忙
    WriteEnable();                      //SET WEL
    CS=0;                               //使能器件   
    SPI_RW(0x02);   				    //发送写命令 
    SPI_RW((unchar)((addr)>>8));
    SPI_RW((unchar)addr);
    
    SPI_RW(dat);
    CS=1;                               //关闭片选
	WriteDisable(); 
    while(SPI_ReadStatus()&0x01);
}
/*-------------------------------------------------
 * 函数名：SPI_INITIAL
 * 功能：  SPI初始化函数
 * 输入：  无
 * 输出：  无
 --------------------------------------------------*/
void SPI_INITIAL(void)
{
	PCKEN |= 0B00010000;      			//开启SPI时钟
    SPICTRL = 0B00001000;	 
    //Bit7:传输完成标志
	//0：表示没有传输完成或者已经清零
	//1：传输完成标志位，写零清理，写1无效
    
	//Bit6:BUF写入失败标识，
	//0：BUF写入正常
	//1：BUF为非空时，进行写入会置位该位，写零清理，写1无效
    
	//Bit5:工作模式错误标识,
	//0：工作模式正常
	//1：当SPI配置为主机模式，并且NSS用作输入引脚时，若NSS引进为低电平就会产生置位该位
	//写零清零，写1无效
    
	//Bit4:接收溢出标志
	//0：接收正常
	//1：接收溢出，写零清理，写1无效
    
	//Bit[3:2]:NSS引脚模式选择，当用作输出模式时，相应的IO脚会被用作NSS输出
	//00:禁用NSS引脚
	//01:NSS引脚用作输入
	//1x:NSS引脚用作输出，输出的值等于NSSM[0]的值
	//注：NSS引脚配置为输入状态时，可以被SSM的软件管理模式屏蔽掉
    
	//Bit1:发送BUFF为空状态
	//0：发送BUF非空
	//1：发送BUF位空
    
	//Bit0:SPI接口使能
	//0：禁用SPI模块
	//1：启用SPI模块，相应的IO会被用作SPI的功能

    SPICFG = 0B01000000;   
    //Bit7:SPI  BUSY状态
	//0：SPI模块空闲
	//1：表示SPI模块忙绿中
    
	//Bit6:MASTER使能位
	//0：工作在SLAVE模式
	//1：工作在MSATER模式
    
	//Bit5:SCK相位选择
	//0：第一个时钟转换的沿是数据采样点
	//1：第二个时钟转换的沿是数据采样点
    
	//Bit4:SCK极性选择
	//0：SPI空闲时，SCK的时钟是处于低电平状态
	//1：SPI空闲时，SCK的时钟是处于高电平状态
    
	//Bit3:SLAVE选择标志
	//0：该模块未被选中
	//1：该模块被选中
	//注：当NSS用作输入时，该值可以被SSM软件管理，当SSM为1时，这里的值表示的是SSI的值取反
    
	//Bit2:NSS引脚的输入值状态
	//注：当NSS用作输入时，该值可以被SSM软件管理，当SSM为1时，这里的值表示的是SSI的值
    
	//Bit1:移位寄存器为空状态
	//0：内部串行移位寄存器非空
	//1：内部串行移位寄存器为空

	//Bit0:接受BUFFER为空状态
	//0：表示接收BUF非空
	//1：接收BUF为空状态

    SPISCR = 0B00000000;  					//波特率设置,SPI时钟8M   16/(2*(SPISCR+1))
    SPIRXCRC = 0B00000000;	 				//接收数据的CRC计算结果
    SPITXCRC = 0B00000000;	 				//发送数据的CRC计算结果
    SPIIER = 0B00000000;	 				//禁用SPI中断
    SPICTRL2 = 0B00000000;
    //Bit7:半双工使能
	//0：禁用半双工模式
	//1：使能半双工模式
    
	//Bit6:半双工模式的接收使能
	//0：半双工模式接收使能
	//1：半双工模式发送使能
    
	//Bit5:全双工模式只允许接收使能
	//0：全双工模式允许发送和接收
	//1：全双工模式只允许接收
    
	//Bit4:NSS输入管脚的值，仅当SSM置1时有效
	//0：输入到NSS引脚的值是0
	//1：输入发哦NSS引脚的值是1
    
	//Bit3:软件SLAVE模式管理，使能后NSS引脚的值由SSI替代
	//0：禁用NSS引脚的软件管理模式
	//1：启用NSS引脚的关键管理模式，如果NSS引脚用作输入，则NSS引脚实际的值有SSI取代
    
	//Bit2:置位后在TXBUFF为空时会把TXCRC的值写入TXBUFF
	//0：不传送TXCRC的值到TXBUF
	//1：等待TXBMT为1时，传送TXCRC的值到TXBUF，写入完成后改位自动清零
    
	//Bit1:CRC模块计算使能
	//0：禁用CRC校验模块
	//1：启用CRC校验模块
    
	//Bit0:发送低比特位使能
	//0：高比特位优先发送
	//1：低比特位优先发送

    SPISTAT = 0B00000000;
    
    SPIEN=1; 				 			//使能SPI
}
/*-------------------------------------------------
 * 函数名: main 
 * 功能：  主函数
 * 输入：  无
 * 输出：  无
 --------------------------------------------------*/
void main(void)
{
	SPIReadData=0;
	SPIReadData1=0;
	POWER_INITIAL();					//系统初始化
    SPI_INITIAL();  					//SPI初始化
    
    SPI_Write(0x0013,0x55); 				//写0x13地址
    SPI_Write(0x0014,0x88); 				//写0x14地址
    
	SPIReadData = SPI_Read(0x0013); 		//读取0x13地址值 
    NOP();
    SPIReadData1 = SPI_Read(0x0014); 		//读取0x14地址值 
    
	while(1)
	{
    	NOP();
	}
}