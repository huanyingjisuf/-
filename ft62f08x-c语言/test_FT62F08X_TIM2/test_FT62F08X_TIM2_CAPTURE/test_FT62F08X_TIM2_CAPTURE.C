//********************************************************* 
/* 文件名: TEST_62F08x_TIM2_CAPTURE.c
* 功能：   FT62F08x-TIM2_CAPTURE功能演示
* IC:      FT62F088 LQFP32
* 内部：   16M
* empno:   500                                 
* 说明：   例程通过TIM2的捕获通道1测量TIM4输出到PB3的波形的周期（4K）
*		   TIM2计数器捕获的数据放在testdata数组里，一共20个。
*          程序只用到一个数据(testdata[1])来计算周期。	
*
*   参考原理图 TEST_62F08x_sch.pdf
*/
//*********************************************************
#include "SYSCFG.h"
//***********************宏定义****************************
#define  unchar     unsigned char 
#define  unint      unsigned int

#define  DemoPortOut	PB3   
#define  DemoPortOut1	PB4

volatile unint testdata[20];
volatile unchar  y=0;
volatile unchar dataH;
volatile unchar dataL;
volatile unint  period=0;
/*-------------------------------------------------
 * 函数名：interrupt ISR
 * 功能：  中断处理函数，包括定时器2与4
 * 输入：  无
 * 输出：  无
 --------------------------------------------------*/
void interrupt ISR(void)            
{ 
  	//定时器4的中断处
	if(T4UIE && T4UIF)                	
	{
		T4UIF = 1;                    	//写1清零标志位             
		DemoPortOut = ~DemoPortOut; 	//翻转电平
	} 
    
  	//定时器2的中断处理
	if(T2CC1IE && T2CC1IF)              //捕获中断	
	{
		T2CC1IF = 1;                    //写1清零标志位 
        
        TIM2CNTRH = 0x00;                
        TIM2CNTRL = 0x00;
                    
		DemoPortOut1 = ~DemoPortOut1; 	//翻转电平
        
        dataH = TIM2CCR1H;
        dataL = TIM2CCR1L;
            
        testdata[y++] =(unint)(dataH<<8 | dataL);
        NOP();
        
        if(y>=20)
        {
        	y=0;
            
            //计算周期(us)
            period = testdata[1]/32;   //周期约等于250us
        }
	} 
}  
/*-------------------------------------------------
 * 函数名：POWER_INITIAL
 * 功能：  上电系统初始化
 * 输入：  无
 * 输出：  无
 --------------------------------------------------*/	
void POWER_INITIAL (void) 
{
	OSCCON = 0B01110001;	//IRCF=111=16MHz 1:1
	INTCON = 0;  			//暂禁止所有中断
    
	PORTA = 0B00000000;		
	TRISA = 0B00100000;		//PA输入输出 0-输出 1-输入  PA5-IN
	PORTB = 0B00000000;		
	TRISB = 0B00000000;		//PB输入输出 0-输出 1-输入	PB3,PB4-OUT						
	PORTC = 0B00000000; 	
	TRISC = 0B00000000;		//PC输入输出 0-输出 1-输入  	
    PORTD = 0B00000000;		
	TRISD = 0B00000000;		//PD输入输出 0-输出 1-输入
	
	WPUA = 0B00000000;     	//PA端口上拉控制 1-开上拉 0-关上拉
	WPUB = 0B00000000;     	//PB端口上拉控制 1-开上拉 0-关上拉
	WPUC = 0B00000000;     	//PC端口上拉控制 1-开上拉 0-关上拉
	WPUD = 0B00000000;     	//PD端口上拉控制 1-开上拉 0-关上拉
    
    WPDA = 0B00000000;     	//PA端口下拉控制 1-开下拉 0-关下拉
	WPDB = 0B00000000;     	//PB端口下拉控制 1-开下拉 0-关下拉
	WPDC = 0B00000000;     	//PC端口下拉控制 1-开下拉 0-关下拉
	WPDD = 0B00000000;     	//PD端口下拉控制 1-开下拉 0-关下拉
    
    PSRC0  = 0B11111111;  	//PORTA,PORTB源电流设置最大
    PSRC1  = 0B11111111;    //PORTC,PORTD源电流设置最大    
    
    PSINK0 = 0B11111111;  	//PORTA灌电流设置最大 0:最小，1:最大
    PSINK1 = 0B11111111; 	//PORTB灌电流设置最大 0:最小，1:最大
    PSINK2 = 0B11111111;	//PORTC灌电流设置最大 0:最小，1:最大
    PSINK3 = 0B11111111;	//PORTD灌电流设置最大 0:最小，1:最大
	
    ANSELA = 0B00000000;    //全为数字管脚
}
/*-------------------------------------------------
 * 函数名称：Time4Initial
 * 功能：   初始化定时器4
 * 输入参数：无
 * 返回参数：无 
 -------------------------------------------------*/
void Time4Initial(void)
{
	PCKEN |=0B00001000;      //TIME4模块时钟使能		
    
    TIM4CR1	=0B00000001;
    //Bit7: 0：TIM1_ARR寄存器没有缓冲，它可以被直接写入; 1：TIM1_ARR寄存器由预装载缓冲器缓冲。
    //Bit6: 保留
    //Bit[5:4]: timer4时钟选择位。
	//00：系统时钟/主时钟
	//01：内部快时钟HIRC
	//10：LP时钟，只有当FOSC选择LP模式时才有意义
	//11：XT时钟，只有当FOSC选择XT模式时才有意义

    //Bit3:单脉冲模式
    //0：在发生更新事件时，计数器不停止；
	//1：在发生下一次更新事件(清除CEN位)时，计数器停止。

    //Bit2:更新请求源
   	//0：如果UDIS允许产生更新事件，则下述任一事件产生一个更新中断：
	//寄存器被更新(计数器上溢/下溢)
	//软件设置UG位
	//时钟/触发控制器产生的更新
	//1：如果UDIS允许产生更新事件，则只有当下列事件发生时才产生更新中断，并UIF置1：
	//寄存器被更新(计数器上溢/下溢)

    //Bit1:禁止更新
    //0：一旦下列事件发生，产生更新(UEV)事件：
	//计数器溢出/下溢
	//产生软件更新事件
	//时钟/触发模式控制器产生的硬件复位被缓存的寄存器被装入它们的预装载值。
	//1：不产生更新事件，影子寄存器(ARR、PSC、CCRx)保持它们的值。如果设置了UG位或时钟/触发控制器发出了一个硬件复位，则计数器和预分频器被重新初始化。

    //Bit0: 0：禁止计数器；1：使能计数器。

    TIM4IER	=0B00000001;
    //Bit0:  0：禁止更新中断；1：允许更新中断。

    TIM4SR	=0B00000000;
    //Bit0: 当产生更新事件时该位由硬件置1。它由软件写1清0
	//0：无更新事件产生；
	//1：更新事件等待响应。当寄存器被更新时该位由硬件置1：
	//若TIM4_CR1寄存器的UDIS=0，当计数器上溢或下溢时；
	//若TIM4_CR1寄存器的UDIS=0、URS=0，当设置TIM4_EGR寄存器的UG位软件对计数器
	//CNT重新初始化时；
	//若TIM4_CR1寄存器的UDIS=0、URS=0，当计数器CNT被触发事件重新初始化时。
    
    TIM4EGR	=0B00000000;
    //Bit0:该位由软件置1，由硬件自动清0。
	//0：无动作；
	//1：重新初始化计数器，并产生一个更新事件。注意预分频器的计数器也被清0(但是预分频系数不变)。若在中心对称模式下或DIR=0(向上计数)则计数器被清0；若DIR=1(向下计数)则计数器取TIM1_ARR的值。
    TIM4CNTR=0; //TIM4 8位计数器
    
    TIM4PSCR=0B00000100;
    //预分频器对输入的CK_PSC时钟进行分频。
	//计数器的时钟频率fCK_CNT等于fCK_PSC/2(PSC[2:0])。PSC[7:3]由硬件清0。
	//PSCR包含了当更新事件产生时装入当前预分频器寄存器的值(包括由于清除TIMx_EGR寄存器的UG位产生的计数器清除事件)，
    //这意味着如要新的预分频值生效，必须产生更新事件或者CEN=0。
    
    TIM4ARR	=124;
    //ARR包含了将要装载入实际的自动重装载寄存器的值。
	//当自动重装载的值为空时，计数器不工作。

    INTCON |= 0B11000000;    //开总中断和外设中断
  }
/*-------------------------------------------------
 * 函数名称：Time2Initial
 * 功能：    初始化计时器2
 * 输入参数：无
 * 返回参数：无 
 -------------------------------------------------*/
void Time2Initial(void)
{
	PCKEN |=0B00000100;		//使能timer2时钟模块
    CKOCON=0B00100000;
    TCKSRC=0B00110000;		//TIM2时钟为HIRC的2倍频
    //Bit7低频内振模式：1=256K 振荡频率模式,0 = 32K 振荡频率模式
    
    //Bit[6:4]:TIM2时钟源选择位
	//值	时钟源
	//0		系统时钟/主时钟
	//1		HIRC
	//2		XT时钟/外部时钟
	//3		HIRC的2倍频
	//4		XT时钟/外部时钟的2倍频
	//5		LIRC
	//6		LP时钟/外部时钟
	//7		LP时钟/外部时钟的2位频
    
	//Bit3:保留位
    
	//Bit[2:1]:TIM1时钟源选择位
	//值	时钟源
	//0		系统时钟/主时钟
	//1		HIRC
	//2		XT时钟/外部时钟
	//3		HIRC的2倍频
	//4		XT时钟/外部时钟的2倍频
	//5		LIRC
	//6		LP时钟/外部时钟
	//7		LP时钟/外部时钟的2位频

    TIM2CR1 =0B10000110;  //预载允许，边沿对齐向上计数器，计数器使能
	//Bit7:自动预装载允许位
	//0：TIM2_ARR寄存器没有缓冲，它可以被直接写入；
	//1：TIM2_ARR寄存器由预装载缓冲器缓冲。
    
	//Bit[6:4]:保留位
    
	//Bit3:单脉冲模式
	//0：在发生更新事件时，计数器不停止；
	//1：在发生下一次更新事件(清除CEN位)时，计数器停止。
    
	//Bit2:更新请求源
	//0：如果UDIS允许产生更新事件，则下述任一事件产生一个更新中断：
	//寄存器被更新(计数器上溢/下溢)
	//软件设置UG位
	//时钟/触发控制器产生的更新
	//1：如果UDIS允许产生更新事件，则只有当下列事件发生时才产生更新中断，并UIF置1：
	//寄存器被更新(计数器上溢/下溢)
    
	//Bit1:禁止更新
	//0：一旦下列事件发生，产生更新(UEV)事件：
	//计数器溢出/下溢
	//产生软件更新事件
	//时钟/触发模式控制器产生的硬件复位被缓存的寄存器被装入它们的预装载值。
	//1：不产生更新事件，影子寄存器(ARR_SHAD、PSC_SHAD、CCRx_SHAD)保持它们的值。
    
	//Bit0:允许计数器
	//0：禁止计数器；
	//1：使能计数器。


    TIM2IER =0B00000010;	//允许捕获/比较2中断
	//Bit[7:4]:保留位
	//Bit3:允许捕获/比较3中断
	//0：禁止捕获/比较3中断；
	//1：允许捕获/比较3中断。
	//Bit2:允许捕获/比较2中断
	//0：禁止捕获/比较2中断；
	//1：允许捕获/比较2中断。
	//Bit1:允许捕获/比较1中断
	//0：禁止捕获/比较1中断；
	//1：允许捕获/比较1中断。
	//Bit0:允许更新中断
	//0：禁止更新中断；
	//1：允许更新中断。

    TIM2SR1 =0B00000000;
	//Bit[7:4]:保留位
    
	//Bit3：捕获/比较3中断标记(写1清0，写0无效)
	//参考CC1IF描述。
    
	//Bit2：捕获/比较2中断标记(写1清0，写0无效)
	//参考CC1IF描述。
    
	//Bit1：捕获/比较1中断标记，如果通道CC1配置为输出模式：(写1清0，写0无效)
    //如果通道1配置为输出比较模式：当计数器值与比较值匹配时该位由硬件置1；它由软件清0。
	//0：无匹配发生；
	//1：TIM2_CNT的值与TIM2CCR1H/L的值匹配。
	//如果通道CC1配置为输入模式：当捕获事件发生时该位由硬件置1，它由软件清0或通过读TIM2_CCR1L清0。
	//0：无输入捕获产生；
	//1：计数器值已被捕获(拷贝)至TIM2_CCR1(在IC1上检测到与所选极性相同的边沿)。
    
	//Bit0：更新中断标记(写1清0，写0无效)
    //当产生更新事件时该位由硬件置1。它由软件清0。
	//0：无更新事件产生；
	//1：更新事件等待响应。

    TIM2SR2 =0B00000000;
    
    TIM2EGR =0B00000000;
	//Bit[7:4]:保留位
    
	//Bit3：产生捕获/比较3事件
	//参考CC1G描述。
    
	//Bit2：产生捕获/比较2事件
	//参考CC1G描述。
    
	//Bit1：产生捕获/比较1事件
	//该位由软件置1，用于产生一个捕获/比较事件，由硬件自动清0。
	//0：无动作；
	//1：在通道CC1上产生一个捕获/比较事件： 
    //若通道CC1配置为输出：
	//设置CC1IF=1，若开启对应的中断，则产生相应的中断。
    //若通道CC1配置为输入：
	//当前的计数器值被捕获至TIM2CCR1H/L寄存器，设置T2CC1IF=1，若开启对应的中断，则产生相应的中断。
	//若T2CC1IF已经为1，则设置T2CC1OF=1。
    
	//Bit0：产生更新事件
	//该位由软件置1，由硬件自动清0。
	//0：无动作；
	//1：重新初始化计数器，并产生一个更新事件。
    //注意：
	//预分频器的计数器也被清0(但是预分频系数不变)。若在T2DIR=0(向上计数)则计数器被清0；若T2DIR=1(向下计数)则计数器初始化为TIM1ARRH/L的值。
    
    TIM2CCMR1 =0B00000001;//CC1通道被配置为输出
	//Bit7:保留位
	//Bit[6:4]：输出比较1模式,该3位定义了输出参考信号OC1REF的动作，而OC1REF决定了OC1的值。OC1REF是高电平有效，而OC1的有效电平取决于T2CC1P位。
	//000：冻结。输出比较寄存器TIM2_CCR1与计数器TIM2_CNT间的比较对OC1REF不起作用；
	//001：匹配时设置通道1的输出为有效电平。当计数器TIM2_CNT的值与捕获/比较寄存器1(TIM2_CCR1)相同时，强制OC1REF为高。
	//010：匹配时设置通道1的输出为无效电平。当计数器TIM2_CNT的值与捕获/比较寄存器1(TIM2_CCR1)相同时，强制OC1REF为低。
	//011：翻转。当TIM2_CCR1=TIM2_CNT时，翻转OC1REF的电平。
	//100：强制为无效电平。强制OC1REF为低。
	//101：强制为有效电平。强制OC1REF为高。
	//110：PWM模式1－ 在向上计数时，一旦TIM2_CNT<TIM2_CCR1时通道1为有效电平，否则为无效电平；在向下计数时，一旦TIM2_CNT>TIM2_CCR1时通道1为无效电平(OC1REF=0)， 否则为有效电平(OC1REF=1)。
	//111：PWM模式2－ 在向上计数时，一旦TIM2_CNT<TIM2_CCR1时通道1为无效电平，否则为有效电平；在向下计数时，一旦TIM2_CNT>TIM2_CCR1时通道1为有效电平，否则为无效电平。
	//注1：在PWM模式1或PWM模式2中，只有当比较结果改变了或在输出比较模式中从冻结模式切换到PWM模式时，OC1REF电平才改变。
    
	//Bit3：输出比较1预装载使能
	//0：禁止TIM2_CCR1寄存器的预装载功能，可随时写入TIM2_CCR1寄存器，并且新写入的数值立即起作用。
	//1：开启TIM2_CCR1寄存器的预装载功能，读写操作仅对预装载寄存器操作，TIM2_CCR1的预装载值在更新事件到来时被加载至当前寄存器中。
	//注1：一旦LOCK级别设为3(TIM2_BKR寄存器中的LOCK位)并且CC1S=00(该通道配置成输出) 则该位不能被修改。
	//注2：为了操作正确，在PWM模式下必须使能预装载功能。但在单脉冲模式下(TIM2_CR1寄存器的OPM=1)，它不是必须的。
    
	//Bit2：输出比较1 快速使能,该位用于加快CC输出对触发输入事件的响应。
	//0：根据计数器与CCR1的值，CC1正常操作，即使触发器是打开的。当触发器的输入有一个有效沿时，激活CC1输出的最小延时为5个时钟周期。
	//1：输入到触发器的有效沿的作用就象发生了一次比较匹配。因此，OC被设置为比较电平而与比较结果无关。采样触发器的有效沿和CC1输出间的延时被缩短为3个时钟周期。
	//OCFE只在通道被配置成PWM1或PWM2模式时起作用。
    
	//Bit[1:0]：捕获/比较1 选择。这2位定义通道的方向(输入/输出)，及输入脚的选择：
	//00：CC1通道被配置为输出；
	//01：CC1通道被配置为输入，IC1映射在TI1FP1上；
	//10：CC1通道被配置为输入，IC1映射在TI2FP1上；
	//11：CC1通道被配置为输入，IC1映射在TRC上。此模式仅工作在内部触发器输入被选中时(由
	//TIM2_SMCR寄存器的TS位选择)。
	//注：CC1S仅在通道关闭时(TIM2_CCER1寄存器的CC1E=0)才是可写的。
    
    TIM2CCER1 =0B00000001; //比较2互补输出使能，低电平有效；比较器1输出使能，低电平有效
	//Bit5：输入捕获/比较2输出极性。参考T2CC1P的描述。
	//Bit4：输入捕获/比较2输出使能。参考T2CC1E的描述。
    
	//Bit1：输入捕获/比较1输出极性CC1通道配置为输出：
	//0：OC1高电平有效；
	//1：OC1低电平有效。
	//CC1配置为触发输入：
	//0：触发发生在TI1F的高电平或上升沿；
	//1：触发发生在TI1F的低电平或下降沿。
	//CC1通道配置为输入：
	//0：捕捉发生在TI1F的高电平或上升沿；
	//1：捕捉发生在TI1F的低电平或下降沿。
    
	//Bit0：输入捕获/比较1输出使能
	//CC1通道配置为输出：
	//0： 关闭－ OC1禁止输出。
	//1： 开启－ OC1信号输出到对应的输出引脚。
    //CC1通道配置为输入：
	//该位决定了计数器的值是否能捕获入TIM2_CCR1寄存器。
	//0：捕获禁止；
	//0：捕获使能。
    
    TIM2CNTRH =0B00000000;		//TIM2计数器
    TIM2CNTRL =0B00000000;
    
    TIM2PSCR =0B00000000;

    T2CEN =1;
  }
/*-------------------------------------------------
 * 函数名: main 
 * 功能：  主函数
 * 输入：  无
 * 输出：  无
 --------------------------------------------------*/
void main(void)
{
	POWER_INITIAL();		//系统初始化
    Time2Initial();
    Time4Initial();
	while(1)
	{
		NOP();
	}
}