C51 COMPILER V9.51   UART                                                                  05/14/2019 10:45:05 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE UART
OBJECT MODULE PLACED IN .\output\uart.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE source\uart.c OMF2 BROWSE DEBUG PRINT(.\lst\uart.lst) TABS(2) OBJECT(.\outp
                    -ut\uart.obj)

line level    source

   1          #ifndef _UART_C_
   2          #define _UART_C_
   3          #include "include/ca51f_config.h"
   4          #include "include/ca51f3sfr.h"
   5          #include "include/ca51f3xsfr.h"
   6          #include "include/gpiodef_f3.h"
   7          
   8          #include "include/uart.h"
   9          #include "include/adc.h"
  10          #include <intrins.h>
  11          #include <string.h>
  12          #include <stdarg.h>
  13          #include <stdlib.h>
  14          #include <stdio.h>
  15          #include <absacc.h>
  16          /*********************************************************************************************************
             -************/
  17          /*********************************************************************************************************
             -************/
  18          #ifdef UART0_EN
  19          void Uart0_Initial(unsigned long int baudrate)
  20          {
  21   1        unsigned int value_temp;
  22   1      
  23   1        P31F = P31_UART0_RX_SETTING;
  24   1        P30F = P30_UART0_TX_SETTING;
  25   1        
  26   1        uart0_send.head=0;
  27   1        uart0_send.tail=0;
  28   1        uart0_rev.head=0;
  29   1        uart0_rev.tail=0;
  30   1        uart0_tx_flag=0;
  31   1      
  32   1      /*********************************************************************************************************
             -***************/
  33   1      //TIMER2作为UART0的波特率发生器
  34   1        value_temp = 0x10000 - FOSC/(baudrate*32);
  35   1        T2CON =   0x24;
  36   1        T2CH  =   (unsigned char)(value_temp>>8);
  37   1        T2CL  =   (unsigned char)(value_temp);
  38   1        TH2   =   (unsigned char)(value_temp>>8);
  39   1        TL2   =   (unsigned char)(value_temp);; 
  40   1        TR2   =   1;
  41   1      /*********************************************************************************************************
             -***************/  
  42   1      
  43   1      
  44   1      /*********************************************************************************************************
             -***************/
  45   1      //TIMER1作为UART0的波特率发生器
  46   1      
  47   1      //  TMOD = (TMOD&0xCF)|0x20;
  48   1      //  TH1 = 0xff;   //19200
  49   1      //  TL1 = 0xff;
C51 COMPILER V9.51   UART                                                                  05/14/2019 10:45:05 PAGE 2   

  50   1      //  ET1=0;
  51   1      //  TR1=1;    
  52   1      //  PCON |= 0x80;   
  53   1      /*********************************************************************************************************
             -***************/
  54   1      
  55   1      
  56   1        S0CON = 0x50;  
  57   1        ES0 = 1;
  58   1      }
  59          void Uart0_PutChar(unsigned char bdat)
  60          {
  61   1        unsigned char free_space;
  62   1        unsigned char tail_tmp;
  63   1        while(1)
  64   1        {       
  65   2          tail_tmp = uart0_send.tail; 
  66   2          if(uart0_send.head < tail_tmp)
  67   2          {
  68   3            free_space = tail_tmp - uart0_send.head;
  69   3          }
  70   2          else
  71   2          {
  72   3            free_space = UART0_TX_BUF_SIZE + tail_tmp - uart0_send.head;
  73   3          }   
  74   2          if(free_space > 1)
  75   2          {
  76   3            ES0 = 0; 
  77   3            uart0_send.head++;
  78   3            uart0_send.head %= UART0_TX_BUF_SIZE;
  79   3            uart0_tx_buf[uart0_send.head] = bdat;     
  80   3            if(!uart0_tx_flag)
  81   3            {
  82   4              ES0 = 1;        
  83   4              uart0_send.tail++;
  84   4              uart0_send.tail %= UART0_TX_BUF_SIZE;   
  85   4              S0BUF=uart0_tx_buf[uart0_send.tail];        
  86   4              uart0_tx_flag = 1;    
  87   4            }
  88   3            else
  89   3            {
  90   4              ES0 = 1;  
  91   4            }     
  92   3            break;
  93   3          }
  94   2        }
  95   1      }
  96          void UART0_ISR (void) interrupt 4
  97          { 
  98   1        if(RI0)
  99   1        {
 100   2          RI0 = 0;
 101   2          uart0_rev.head++;
 102   2          uart0_rev.head %= UART0_RX_BUF_SIZE;
 103   2          uart0_rx_buf[uart0_rev.head]=S0BUF;
 104   2        }
 105   1        if(TI0)
 106   1        { 
 107   2          TI0 = 0;    
 108   2          if(uart0_send.head!=uart0_send.tail)
 109   2          {
 110   3            uart0_send.tail++;
C51 COMPILER V9.51   UART                                                                  05/14/2019 10:45:05 PAGE 3   

 111   3            uart0_send.tail %= UART0_TX_BUF_SIZE;
 112   3            S0BUF=uart0_tx_buf[uart0_send.tail];        
 113   3          }
 114   2          else
 115   2          {
 116   3            uart0_tx_flag=0;
 117   3          } 
 118   2        }
 119   1      }
 120          #endif
 121          #ifdef UART1_EN
              void Uart1_Initial(unsigned long int baudrate)
              {
                unsigned int value_temp;
              
                uart1_send.head=0;
                uart1_send.tail=0;
                uart1_rev.head=0;
                uart1_rev.tail=0;
                uart1_tx_flag=0;
              
                value_temp = 0x400 - FOSC/(baudrate*32);
              
              
                P12F = P12_UART1_RX_SETTING;
                P11F = P11_UART1_TX_SETTING;
              
              
                S1RELH = (unsigned char)(value_temp>>8);
                S1RELL = (unsigned char)(value_temp);
                
                S1CON = 0xD0;
                ES1 = 1;  
              }
              void Uart1_PutChar(unsigned char bdat)
              {
                unsigned char free_space;
                unsigned char tail_tmp;
                while(1)
                {   
                  tail_tmp = uart1_send.tail;
                  if(uart1_send.head < tail_tmp)
                  {
                    free_space = tail_tmp - uart1_send.head;
                  }
                  else
                  {
                    free_space = UART1_TX_BUF_SIZE + tail_tmp - uart1_send.head;
                  }   
                  if(free_space > 1)
                  {
                    ES1 = 0; 
                    uart1_send.head++;
                    uart1_send.head %= UART1_TX_BUF_SIZE;
                    uart1_tx_buf[uart1_send.head] = bdat;
                    if(!uart1_tx_flag)
                    {
                      ES1 = 1;
                      uart1_send.tail++;
                      uart1_send.tail %= UART1_TX_BUF_SIZE;   
                      S1BUF = uart1_tx_buf[uart1_send.tail];        
                      uart1_tx_flag = 1;    
C51 COMPILER V9.51   UART                                                                  05/14/2019 10:45:05 PAGE 4   

                    }
                    else
                    {
                      ES1 = 1;  
                    }     
                    break;
                  }
                }
              }
              void UART1_ISR (void) interrupt 6 
              {
                if(S1CON & BIT0)
                {
                  S1CON = (S1CON&~(BIT0|BIT1))|BIT0;       
                  uart1_rev.head++;
                    uart1_rev.head %= UART1_RX_BUF_SIZE;
                  uart1_rx_buf[uart1_rev.head]=S1BUF;
                }
                if(S1CON & BIT1)
                {
                  S1CON = (S1CON&~(BIT0|BIT1))|BIT1;  
                  if(uart1_send.head!=uart1_send.tail)
                  {
                    uart1_send.tail++;
                    uart1_send.tail %= UART1_TX_BUF_SIZE;
                    S1BUF=uart1_tx_buf[uart1_send.tail];        
                  }
                  else
                  {
                    uart1_tx_flag=0;
                  }   
                }
              }
              #endif
 207          
 208          #ifdef PRINT_EN
 209            #ifdef UART0_PRINT
 210              #define Uart_PutChar  Uart0_PutChar
 211            #elif defined  UART1_PRINT
                  #define Uart_PutChar  Uart1_PutChar
                #endif
 214          void UartPutStr(char *str)
 215          {
 216   1        while(*str)
 217   1        { 
 218   2          Uart_PutChar(*str++);
 219   2        }
 220   1      }
 221          void uart_printf(char *fmt,...) 
 222          {
 223   1          va_list ap;
 224   1          char xdata string[256];
 225   1          va_start(ap,fmt);
 226   1          vsprintf(string,fmt,ap);
 227   1          UartPutStr(string);
 228   1          va_end(ap);
 229   1      }
 230          #endif
 231          /*********************************************************************************************************
             -************/
 232          #endif

C51 COMPILER V9.51   UART                                                                  05/14/2019 10:45:05 PAGE 5   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    378    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    104     256
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20      28
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
