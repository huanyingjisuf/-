C51 COMPILER V9.02   MAIN                                                                  11/21/2021 20:27:15 PAGE 1   


C51 COMPILER V9.02, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\output\main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE source\main.c OMF2 BROWSE DEBUG PRINT(.\lst\main.lst) OBJECT(.\output\main.
                    -obj)

line level    source

   1          
   2          #ifndef _MAIN_C_
   3          #define _MAIN_C_
   4          /*********************************************************************************************************
             -************/
   5          #include "include/ca51f_config.h"               
   6          #include "include/ca51f3sfr.h"
   7          #include "include/ca51f3xsfr.h"
   8          #include "include/gpiodef_f3.h"
   9          #include "include/system_clock.h"
  10          
  11          #include "include/uart.h"
  12          #include "include/pwm.h"
  13          #include "include/delay.h"
  14          #include <intrins.h>
  15          /*********************************************************************************************************
             -************
  16                  本例程设置PWM0、PWM1输出频率为30KHZ、互补并带死区控制的PWM信号
  17          
  18                  备注：
  19                  1、PWM有多种时钟源可以选择，时钟源是以两路PWM为单位进行设置的，
  20                  分别是：PWM0 和 PWM1、PWM2 和 PWM3、PWM4 和 PWM5、PWM6 和 PWM7，
  21                  也就是说，每组PWM的时钟源是共同设置的，时钟源通过 PWM0、PWM2、
  22                  PWM4、PWM6对应的控制寄存器 PWMCON 的PWMCKS来选择。
  23          
  24                  2、PWMCON、PWMCFG、PWMDIVH、PWMDIVL、PWMDUTH、PWMDUTL等寄存器是
  25                  带索引的寄存器，设置带索引的寄存器前先设置INDEX寄存器，具体操作
  26                  请参考下面的例子
  27          **********************************************************************************************************
             -***********/
  28          #define PWMDIV_V                                (3686400/30000)         //当PWM时钟为其他时钟频率时，需相应修改参数
  29          #define PWMDUT_V                                (PWMDIV_V/2)                    //占空比为50%
  30          
  31          void main(void)
  32          {
  33   1      #ifdef LVD_RST_ENABLE
  34   1              LVDCON = 0xE1;                                  //设置LVD复位电压为2V
  35   1      #endif
  36   1      
  37   1      #if (SYSCLK_SRC == PLL)
                      Sys_Clk_Set_PLL(PLL_Multiple);  //设置系统时钟为PLL，PLL_Multiple为倍频倍数
              #endif
  40   1              
  41   1      #ifdef UART0_EN
                      Uart0_Initial(UART0_BAUTRATE);  //初始化UART0
              #endif
  44   1              
  45   1      #ifdef UART1_EN
                      Uart1_Initial(UART1_BAUTRATE);  //初始化UART1
              #endif
  48   1      
  49   1              EA = 1;                                                                                                 //开全局中断
  50   1      
  51   1      #ifdef PRINT_EN
C51 COMPILER V9.02   MAIN                                                                  11/21/2021 20:27:15 PAGE 2   

                      uart_printf("PWM Complementary Mode Demo Code\n");
              #endif
  54   1      
  55   1              
  56   1              CKCON |= IHCKE;                         //打开IRCH时钟
  57   1      //      CKCON |= ILCKE;                         //打开IRCL时钟
  58   1      //      CKCON |= TFCKE;                         //打开TFRC时钟
  59   1      
  60   1      //      GPIO_Init(P32F,P32_XOSC_IN_SETTING);
  61   1      //      GPIO_Init(P33F,P33_XOSC_OUT_SETTING);
  62   1      //      CKCON |= XLCKE;
  63   1      //      while(!(CKCON & XLSTA));
  64   1      //      CKSEL = (CKSEL&0xF8) | CKSEL_XOSCL;             //打开XSOCL时钟
  65   1      
  66   1      
  67   1      //      PLLCON = PLLON(1) | MULFT(7);
  68   1      //      while(!(PLLCON & PLSTA));
  69   1      //      CKSEL = (CKSEL&0xF8) | CKSEL_PLL;                       //打开PLL时钟
  70   1      
  71   1              
  72   1              P15F = P15_PWM0_SETTING;                                                                //设置P15为PWM引脚功能
  73   1              P16F = P16_PWM1_SETTING;                                                                //设置P16为PWM引脚功能
  74   1      
  75   1              INDEX = PWM_CH0;                                                                                                        //设置INDEX值对应PWM0
  76   1              PWMCON = TIE(0) | ZIE(0) | PIE(0) | NIE(0) | MS(0) | CKS_IH ;           //设置PWM时钟源为IRCH  
  77   1      //      PWMCON = TIE(0) | ZIE(0) | PIE(0) | NIE(0) | MS(0) | CKS_IL ;           //设置PWM时钟源为IRCL
  78   1      //      PWMCON = TIE(0) | ZIE(0) | PIE(0) | NIE(0) | MS(0) | CKS_XL ;           //设置PWM时钟源为XOSCL  
  79   1      //      PWMCON = TIE(0) | ZIE(0) | PIE(0) | NIE(0) | MS(0) | CKS_TF ;           //设置PWM时钟源为TFRC 
  80   1      //      PWMCON = TIE(0) | ZIE(0) | PIE(0) | NIE(0) | MS(0) | CKS_PLL ;          //设置PWM时钟源为PLL  
  81   1              PWMCFG = TOG(0) | 0;                                                                                                                                                                                            
  82   1              
  83   1              //设置PWMDIV、PWMDUT
  84   1              PWMDIVH = (unsigned char)(PWMDIV_V>>8);                 
  85   1              PWMDIVL = (unsigned char)(PWMDIV_V);                    
  86   1              PWMDUTH = (unsigned char)(PWMDUT_V>>8);         
  87   1              PWMDUTL = (unsigned char)(PWMDUT_V);    
  88   1              
  89   1              
  90   1              INDEX = PWM_CH1;
  91   1              PWMCON = TIE(0) | ZIE(0) | PIE(0) | NIE(0) | MS(0) | MOD(1);                    //设置互补模式
  92   1              PWMCFG = TOG(0) | 0;
  93   1              
  94   1              //设置死区时间约2us
  95   1              PWMDIVH = 0;
  96   1              PWMDIVL = 7;
  97   1              PWMDUTH = 0;
  98   1              PWMDUTL = 7;    
  99   1      
 100   1              PWMUPD = (1<<PWM_CH0)|(1<<PWM_CH1);                                                                     //PWMDIV、PWMDUT更新使能
 101   1              while(PWMUPD);                                                                                                                                                  //等待更新完成
 102   1              PWMEN = (1<<PWM_CH0)|(1<<PWM_CH1);                                                                      //PWM0、PWM1使能
 103   1              
 104   1              while(1)
 105   1              {
 106   2              }
 107   1      }
 108          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =     64    ----
   CONSTANT SIZE    =   ----    ----
C51 COMPILER V9.02   MAIN                                                                  11/21/2021 20:27:15 PAGE 3   

   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
